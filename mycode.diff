diff --git a/Makefile b/Makefile
index dcaa3dc..bc391af 100644
--- a/Makefile
+++ b/Makefile
@@ -140,6 +140,9 @@ UPROGS=\
        $U/_bcachetest\
        $U/_mounttest\
        $U/_crashtest\
+       $U/_sleep\
+       $U/_find\
+       $U/_xargs               

 fs.img: mkfs/mkfs README user/xargstest.sh $(UPROGS)
        mkfs/mkfs fs.img README user/xargstest.sh $(UPROGS)
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..5efb198
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,113 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char*
+fmtname(char *path)
+{ 
+// static char buf[DIRSIZ+1];
+   char *p;
+     
+       // Find first character after last slash.
+         for(p=path+strlen(path); p >= path && *p != '/'; p--)
+                ; 
+                         p++;
+       // Return blank-padded name.
+       // if(strlen(p) >= DIRSIZ)
+       // return p;
+       // memmove(buf, p, strlen(p));
+       // memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+       // return buf;                   
+        
+        return p;
+}
+
+// This function searches for a file with the given filename in the directory specified by the path.
+void find(char *path, char* filename)
+{ 
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+ 
+  // If the current path is the file we are looking for, print the path. 
+  if(!strcmp(fmtname(path), filename))
+  {     
+        printf("%s\n", path);
+  }
+  
+  // Open the directory specified by the path.
+  if((fd = open(path, 0)) < 0)
+  {     
+         fprintf(2, "find: cannot open %s\n", path, fd);
+         return;
+   }
+ // Get the status of the directory.
+  if(fstat(fd, &st) < 0)
+  { 
+    fprintf(2, "find: cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+  
+  // If the path is not a directory, close the file descriptor and return.
+  if(st.type != T_DIR)
+  {     
+        close(fd);
+        return;
+  }
+  
+  // If the path is too long, print an error message, close the file descriptor and return.
+  if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf)
+  {     
+        printf("find: path too long\n");
+         close(fd);
+        return;
+  }
+
+  // Copy the path to the buffer and append a slash to it.
+  strcpy(buf, path);
+  p = buf+strlen(buf);
+  *p++ = '/';
+
+  // Read the directory entries one by one.
+  while (read(fd, &de, sizeof(de)) == sizeof(de))
+  {
+       // If the inode number is 0, continue to the next entry.
+        if(de.inum == 0)
+        {
+                continue;
+        }
+       
+       // Copy the name of the entry to the buffer.
+        memmove(p, de.name, DIRSIZ);
+        p[DIRSIZ] = 0;
+       
+       // If the entry is "." or "..", continue to the next entry.
+        if(!strcmp(de.name, ".") || !strcmp(de.name, ".."))
+        {
+                continue;
+        }
+
+       // Recursively call the find function with the new path.
+        find(buf, filename);
+   }
+  // Close the file descriptor.
+  close(fd);
+}
+
+int main(int argc, char *argv[])
+{
+
+  // Check if the arguments are valid.
+  if(argc < 2)
+  {
+    printf("Usage: find path filename\n");
+    exit();
+  }
+
+  // Call the find function with the specified path and filename.
+  find(argv[1], argv[2]);
+  exit();
+}
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..e6e1da3
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,39 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+  int i, n;
+
+  // Check if the user provided the required argument
+  if(argc < 2)
+  {
+    printf("Usage: sleep <number of ticks>...\n");
+    exit();
+  }
+   
+  // Loop through each argument provided by the user
+  for(i = 1; i < argc; i++)
+  {
+    // Convert the argument to an integer
+    n = atoi(argv[i]);
+
+    // Print a message indicating how long the program will sleep     
+    printf("sleep: sleeping for %d ticks\n", n);    
+   
+    // Sleep for the specified number of ticks
+    sleep(n);
+  
+    // Attempt to delete the file specified by the argument 
+    if(unlink(argv[i]) < 0)
+    {
+     // If the file could not be deleted, print an error message and exit the loop
+      printf("rm: %s failed to delete\n", argv[i]);
+     
+      break;
+    }
+  }
+  
+  exit();
+}
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..369c1ee
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,74 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/param.h"
+
+int main(int argc, char *argv[]) 
+{
+    // Initialize variables
+    int temp  = 0;
+    int _argc = 1;
+    char *_argv[MAXARG];
+    char buffer;
+    int i = 0;
+
+    // Check if the first argument is "-n"
+    if(strcmp(argv[1], "-n") == 0) 
+    {
+        temp = 3;
+    } 
+   
+    else 
+    {
+        temp = 1;
+    }
+
+    // Copy the command to _argv[0]
+    _argv[0] = malloc(strlen(argv[temp]) + 1);
+    strcpy(_argv[0], argv[temp]);
+
+    // Copy the rest of the arguments to _argv
+    for(int i = temp + 1; i < argc; ++i) 
+    {
+        _argv[_argc] = malloc(strlen(argv[i]) + 1);
+        strcpy(_argv[_argc++], argv[i]);
+    }
+
+    // Allocate memory for the buffer
+    _argv[_argc] = malloc(128);
+
+    // Read input from stdin
+    while(read(0, &buffer, 1)) 
+    {
+        // Check if the input is a newline character
+        if(buffer == '\n') 
+        {
+            // Terminate the buffer with a null character
+            _argv[_argc][i++] = '\0';
+           
+           // Fork a new process and execute the command
+           if(fork() == 0) 
+            {
+                exec(argv[temp], _argv);
+            } 
+            
+            else 
+            {
+                // Reset the buffer index and wait for the child process to finish
+               i = 0;
+               wait();
+            }
+        } 
+        
+        else 
+        {
+            // Add the input character to the buffer
+            _argv[_argc][i++] = buffer;
+        }
+    }
+
+    // Exit the program
+    exit();
+}
+

                             
